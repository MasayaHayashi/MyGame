//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
// Goal.cpp
// Author : Masaya Hayashi
//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

// ===== インクルード部 =====
#include "../Goal/Goal.h"
#include "../ResoueceManager/ResourceManager.h"
#include "../GameManager/GameManager.h"
#include "../Collision/Collision.h"

//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
// コンストラクタ
//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
Goal::Goal()
{

}

//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
// コンストラクタ
//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
Goal::Goal(std::string keyName, std::string textureName,size_t setNumber)
{
	tagName					= keyName;
	idNumber				= setNumber;
	modelPasses[keyName]	= passName + keyName;
	texturePasses[keyName]	= passName + textureName;
	isFieldObject			= false;
	myGameObjType			= GameObjectType::GoalObj;
	
	isUsed = false;
}

//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
// デストラクタ
//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
Goal::~Goal()
{

}

//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
// ブロック初期化
//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
void Goal::initialize()
{
	// ファイルパス設定
	strcpy_s(fileName, modelPasses[tagName].c_str() );
	strcpy_s(texFileName, texturePasses[tagName].c_str() );

	// モデル生成
	ResourceManager::makeModel(meshDataObj, fileName, meshType);
	ResourceManager::createTexture(textureData, texFileName);

	Collision::registerList(&myTransform, tagName);

	// 位置、移動量、拡大率初期化
	myTransform.scale	= D3DXVECTOR3(1.0f, 1.0f, 1.0f);
	myTransform.rotDeg	= D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	myTransform.pos		= D3DXVECTOR3(0.0f, -meshDataObj.collitionBox.y * 2.0f, 0.0f);
	myTransform.collisionBox = meshDataObj.collitionBox;
	isFieldObject = true;
}

//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
// ブロック後処理
//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
void Goal::finalize()
{
	ResourceManager::destroyAllMesh();

	modelPasses.clear();
	texturePasses.clear();
	ResourceManager::destroyAllTexture();

	Collision::release(tagName);
}

//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
// ブロック更新
//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
void Goal::update()
{
	updateExportData();

	if (!isUsed)
	{
		return;
	}

	if (Collision::getTransform(tagName).front()->isHitAABB)
	{
		GameManager::changeGameType(GameManager::GameType::Goal);
	}

	myTransform.rotDeg.y += D3DXToRadian(2);

	// コライダー更新
//	pCollider->UpdateCollider(mtxWorldPawn, FIELD_BOX_COLOR );
}

//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
// ブロック描画
//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
void Goal::draw()
{
	if (!isUsed)
	{
		return;
	}

	Pawn::draw();
}

//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
// 描画
//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
void Goal::draw(D3DXMATRIX mtxView, D3DXMATRIX mtxProj)
{
	if (!isUsed)
	{
		return;
	}

	Pawn::draw(mtxView,mtxProj);
}

//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
// キー値取得
//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
const std::string Goal::getKeyName()
{
	return tagName;
}